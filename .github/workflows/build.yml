# Nombre del flujo de trabajo de GitHub Actions
name: Compilar Kernel (Vayu)

on:
  workflow_dispatch: # Permite iniciar la compilación manualmente

jobs:
  # TRABAJO 1: Generar la matriz de compilación desde repos.json
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout del repositorio
        uses: actions/checkout@v4

      - name: Generar matriz para los trabajos de compilación
        id: set-matrix
        run: |
          JSON_MATRIX=$(jq -c '.' repos.json)
          echo "matrix={\"include\":${JSON_MATRIX}}" >> $GITHUB_OUTPUT

  # TRABAJO 2: Compilar cada kernel definido en la matriz
  build-kernel:
    needs: generate-matrix
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}

    steps:
      - name: Instalar dependencias
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential libncurses-dev bison flex libssl-dev libelf-dev bc ccache \
            jq git zip device-tree-compiler

      - name: Crear directorios de trabajo
        run: mkdir -p toolchains

      - name: Clonar Toolchains
        run: |
          TOOLCHAINS_JSON='${{ toJSON(matrix.toolchains) }}'
          echo "$TOOLCHAINS_JSON" | jq -c '.[]' | while read -r toolchain; do
            repo=$(echo "$toolchain" | jq -r '.repo')
            branch=$(echo "$toolchain" | jq -r '.branch')
            name=$(echo "$toolchain" | jq -r '.name')
            git clone --depth=1 -b "$branch" "$repo" "toolchains/$name"
          done

      - name: Configurar entorno (PATH y ccache)
        run: |
          for dir in toolchains/*/bin; do [ -d "$dir" ] && echo "$(pwd)/$dir" >> $GITHUB_PATH; done
          ccache -M 50G
          ccache -z
          
      - name: Clonar fuente del Kernel y submódulos
        run: |
          git clone --depth=1 -b ${{ matrix.kernelSource.branch }} ${{ matrix.kernelSource.repo }} kernel_source
          cd kernel_source
          if [ "${{ matrix.withKernelSU }}" = "true" ]; then
            git submodule init
            git submodule update
          fi

      - name: Construir argumentos de compilación
        id: build_args
        run: |
          PARAMS_JSON='${{ toJSON(matrix.params) }}'
          ARGS_STRING=$(echo "$PARAMS_JSON" | jq -r 'to_entries | .[] | .key + "=\"" + .value + "\""' | tr '\n' ' ')
          echo "args=${ARGS_STRING}" >> $GITHUB_OUTPUT

      - name: Generar defconfig
        working-directory: ./kernel_source
        run: |
          # Primero, genera el defconfig base
          make O=../out ${{ steps.build_args.outputs.args }} ${{ matrix.kernelSource.defconfig }}
          
          # Si se especifica KernelSU, habilítalo en la config y actualiza
          if [ "${{ matrix.withKernelSU }}" = "true" ]; then
            echo "CONFIG_KSU=y" >> ../out/.config
            make O=../out ${{ steps.build_args.outputs.args }} olddefconfig
          fi

      - name: Compilar Kernel
        working-directory: ./kernel_source
        env:
          KBUILD_BUILD_USER: "t.me"
          KBUILD_BUILD_HOST: "AnymoreProject"
        run: |
          make O=../out -j$(nproc --all) ${{ steps.build_args.outputs.args }}

      - name: Clonar AnyKernel3 (Base)
        uses: actions/checkout@v4
        with:
          repository: osm0sis/AnyKernel3
          path: AnyKernel3

      - name: Reemplazar anykernel.sh con la versión para Vayu
        run: |
          cat <<'EOF' > AnyKernel3/anykernel.sh
          ### AnyKernel3 Ramdisk Mod Script
          ## osm0sis @ xda-developers

          ### AnyKernel setup
          # global properties
          properties() { '
          kernel.string=AnymoreKernel for Vayu by t.me/AnymoreProject
          do.devicecheck=1
          do.modules=0
          do.systemless=1
          do.cleanup=1
          do.cleanuponabort=0
          device.name1=vayu
          device.name2=bhima
          device.name3=
          device.name4=
          device.name5=
          supported.versions=11 - 17
          supported.patchlevels=
          supported.vendorpatchlevels=
          '; } # end properties


          ### AnyKernel install
          ## boot files attributes
          boot_attributes() {
          set_perm_recursive 0 0 755 644 $ramdisk/*;
          set_perm_recursive 0 0 750 750 $ramdisk/init* $ramdisk/sbin;
          } # end attributes

          # boot shell variables
          block=auto;
          is_slot_device=0;
          ramdisk_compression=auto;
          patch_vbmeta_flag=auto;

          # import functions/variables and setup patching - see for reference (DO NOT REMOVE)
          . tools/ak3-core.sh;

          # boot install
          dump_boot; # use split_boot to skip ramdisk unpack, e.g. for devices with init_boot ramdisk

          write_boot; # use flash_boot to skip ramdisk repack, e.g. for devices with init_boot ramdisk
          ## end boot install
          EOF

      - name: Empaquetar y Crear Zip
        run: |
          # Verificar si la compilación del kernel fue exitosa
          if ! [ -f "out/arch/${{ matrix.params.ARCH }}/boot/Image" ]; then
            echo "Error: La compilación falló, no se encontró el archivo Image."
            exit 1
          fi
          # Copiar los artefactos del kernel al directorio de AnyKernel3
          cp out/arch/${{ matrix.params.ARCH }}/boot/Image AnyKernel3/
          cp out/arch/${{ matrix.params.ARCH }}/boot/dtb.img AnyKernel3/ 2>/dev/null || true
          cp out/arch/${{ matrix.params.ARCH }}/boot/dtbo.img AnyKernel3/ 2>/dev/null || true
          # Crear el archivo zip flasheable
          cd AnyKernel3
          zip -r9 "../${{ matrix.kernelSource.name }}.zip" . -x ".git/*" -x ".github/*"
          cd ..

      - name: Subir artefacto (Zip Flasheable)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.kernelSource.name }}
          path: ${{ matrix.kernelSource.name }}.zip


